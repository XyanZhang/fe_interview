// 10. __proto__ 继承
var person = {
  name: 'person',
  getName: function () {
    return this.name;
  },
};

var person1 = {};
person1.__proto__ = person;
console.log(person1.getName()); // person

// __proto__
// 1. 指向当前对象的原型
// 2. 读取时，如果对象本身没有这个属性，会从原型上读取
// 3. 写入时，如果对象本身没有这个属性，会在对象上新增这个属性，而不会修改原型
// 4. 读取时，如果对象本身和原型上都有这个属性，会读取对象上的属性
// 5. 写入时，如果对象本身和原型上都有这个属性，会修改对象上的属性，而不会修改原型
// 6. 读取时，如果对象本身和原型上都有这个属性，但对象上的属性是一个访问器属性，会读取访问器属性的 getter 方法
// 7. 写入时，如果对象本身和原型上都有这个属性，但对象上的属性是一个访问器属性，会读取访问器属性的 setter 方法
// 8. 读取时，如果对象本身和原型上都有这个属性，但对象上的属性是一个访问器属性，但 getter 方法返回 undefined，会继续从原型上读取
// 9. 写入时，如果对象本身和原型上都有这个属性，但对象上的属性是一个访问器属性，但 setter 方法没有返回值，会继续修改原型上的属性

// 10. __proto__ 继承
// 1. 无法实现复用，每个子类都有父类实例函数的副本，影响性能
// 2. 在创建 Child 的实例时，不能向 Parent 传参
// 3. 无法获取父类不可枚举的方法（不可枚举方法，不能使用 for in 遍历出来）
// 4. 无法判断，某个属性到底是本身的，还是继承的
// 5. 无法判断，对象的原型到底是谁
// 6. 无法判断，对象是否是某个类的实例