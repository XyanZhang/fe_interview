# 大文件上传

## 分片上传

1. 将需要上传的文件按照一定的分割规则，分割成相同大小的数据块
2. 初始化一个分片上传任务，返回本地分片上传唯一标识
3. 按照一定的策略（并行或串行）发送各个数据块，
4. 发送完成后，服务端根据判断数据上传是否完成，如果完整，则进行数据块合并得到原始文件

### 分片上传完成状态判断

后端返回合并成功的信息给前端的时机可以有多种选择，取决于具体的实现方式和需求。以下是两种常见的时机：

+ 前端传完最后一个文件片段：在前端将最后一个文件片段上传到后端后，后端可以进行判断，如果所有文件片段都已经接收完毕，则进行文件合并、校验等操作，并在完成这些操作后，返回合并成功的信息给前端。
+ 后端检测到已经传完并合并完文件：后端可以在接收到每个文件片段时，记录已接收的片段数量，并与需要接收的总片段数量进行对比。当已接收的片段数量等于总片段数量时，后端可以判断所有片段已经传完，并进行文件合并、校验等操作。然后，返回合并成功的信息给前端。

## 断点续传

实现方式

1. 服务端返回，告知从哪儿开始
2. 浏览器端自行处理

上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将次临时文件重命名为正式文件即可

如果中途上传中断过，下次上传的时候根据临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可

### 后端如何判断上传失败

1. 客户端主动通知：前端在上传过程中，可以通过某种方式（例如请求头、请求参数等）将已上传的片段信息发送给后端。后端可以根据这些信息来判断上传是否失败。例如，前端可以在请求中包含已上传片段的偏移量或哈希值等，后端通过比对已接收的片段信息和前端发送的信息，如果有缺失或不匹配，则判断为上传失败。
2. 超时处理：后端设置一个合理的超时时间，如果在超时时间内没有收到新的文件片段请求，就可以判定上传失败。这样可以避免网络异常或客户端意外中断导致的上传失败。
3. 校验文件完整性：后端在接收到最后一个文件片段时，可以对整个文件进行校验。例如，计算文件的哈希值（如MD5、SHA1等），与前端传递过来的文件哈希值进行比对。如果校验不通过，则判断为上传失败。
4. 前端发起重试：如果前端上传失败或检测到失败情况，可以对失败的片段进行重传。前端可以记录上次上传成功的片段信息，并从断点处继续上传。

## 进度显示

实时显示上传进度。前端可以通过XMLHttpRequest的progress事件获取上传进度信息，并将其展示给用户。可以使用进度条、百分比等形式展示上传进度。

### 实现思路

1. 前端将文件切割成多个片段，并为每个片段生成唯一的标识符（例如索引号、哈希值等）。
2. 创建一个FormData对象，用于存储需要上传的文件片段及相关信息。
3. 使用AJAX、Fetch或WebSocket等技术，将FormData对象发送给后端。可以使用POST请求进行传输。
4. 后端接收到请求后，解析表单数据，获取每个片段的数据及相关信息。
5. 后端根据片段的标识符，将每个片段保存到临时文件或内存中。
6. 当所有片段都上传完成后，后端根据标识符将这些片段合并成完整的文件。
7. 合并完成后，可以进行必要的校验操作，例如校验文件的哈希值或其他完整性检查。
8. 最后，返回合并后的文件的相关信息给前端，表示上传成功。

## 流式上传

1. 分块流式上传：将文件分成小的块（chunks），并逐个上传这些块。前端通过File API的slice方法将文件切割成块，并使用AJAX或WebSocket等技术将这些块逐个传输到后端。后端接收到每个块后，可以立即处理和保存，而不需要等待整个文件上传完成。
2. 逐行流式上传：适用于文本文件等可以按行读取的文件。前端将文件按行切分，每次上传一行数据到后端。后端逐行接收并处理这些数据。这种方式特别适合处理大型日志文件等需要实时分析的情况。
3. 实时音视频流上传：适用于实时音视频数据的上传，例如语音通话、视频直播等场景。前端采集音视频数据流，并通过WebRTC或其他相关技术实时传输给后端。后端可以对音视频数据进行处理、编码、存储等操作。
4. 断点续传的流式上传：结合断点续传的思想，可以实现大文件的流式上传。前端将文件分成小的块进行上传，同时记录已上传块的信息。后端接收到每个块后，即可处理和保存，而不需要等待整个文件上传完成。

需要注意的是，流式上传在设计和实现时，需要注意上传过程中的缓冲区管理、上传进度的更新、错误处理等问题。

## 上传过程中刷新网页怎么办

1. 使用断点续传：前端可以在刷新网页前将已成功上传的片段信息保存下来（比如本地存储或通过Cookie等方式），以便在刷新后能够继续上传。刷新后，前端可以读取已保存的片段信息，并向后端发送请求，让后端确认哪些片段已经上传成功，然后从未上传的部分继续上传。
2. 设置上传超时时间：前端可以设置一个上传的超时时间，在规定的时间内没有完成上传操作，就认为上传失败。当用户刷新网页时，前端可以重新发起上传请求，根据需要判断是否需要继续上传之前未上传完的片段。
3. 显示警告信息：前端可以通过监听beforeunload事件，在用户尝试关闭页面或刷新页面时弹出提示框，提醒用户当前正在进行上传操作。用户可以选择留在页面继续上传或离开页面取消上传。

不管采用哪种方案，都需要在前端和后端之间建立一种机制来记录上传的状态和已上传的片段信息，以便在刷新后能够恢复上传进度

## 大文件上传结合 Web Worker

通过postMessage 方法，将切片后文件片段传递给 web worker进行处理，webworker进行验证，加密，压缩，转换格式等操作。这些操作可以并行执行，而不会阻塞主线程，提高了前端应用的性能和响应速度。

将处理后的片段返回给主线程，主线程合并或者重组文件进行上传

> 注：
> Web Worker 有一些限制，例如不能访问 DOM、无法直接调用主线程的函数等。
>
> 大文件的处理可能需要较长的时间，如果这些操作在主线程中执行，会导致主线程被阻塞，影响用户界面的响应和交互

## 秒传

秒传是一种通过校验文件的哈希值或唯一标识来判断文件是否已存在，并跳过重复上传的技术。

1. 客户端计算文件哈希值：客户端在选择文件后，使用哈希算法（如 MD5、SHA1）计算文件内容的哈希值。
2. 将哈希值发送到服务器：客户端将计算得到的文件哈希值发送给服务器，可以通过请求头、请求参数或其他方式传递。
3. 服务器检查哈希值：服务器接收到文件哈希值后，可以查询数据库或进行其他判断，验证是否存在相同哈希值的文件。
4. 响应秒传结果：服务器根据校验结果，向客户端返回相应的响应信息（如状态码），表示是否可以进行秒传。
5. 客户端处理秒传结果：根据服务器返回的响应，客户端可以根据不同的情况作出相应的处理。如果服务器确认文件已存在，则客户端可以直接显示上传成功，并无需再次上传；如果服务器要求继续上传，则客户端需要继续上传剩余的文件内容。

实现秒传功能需要在服务器端进行文件哈希值的管理和比对，并与客户端进行相应的交互。服务器需要保存已上传文件的哈希值或其他唯一标识，以便进行比对和验证。通常，可以将文件哈希值作为文件的唯一标识，并与文件进行关联存储。